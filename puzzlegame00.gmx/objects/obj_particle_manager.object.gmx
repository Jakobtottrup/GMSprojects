<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initializes variables for the particle systems.

// Creates a reference to the particle manager.
global.ps_manager = id;



// Creates a particle system.
ps = part_system_create();

// The number of particle types.
part_count = 6;

/* Initializes first particle type and its parameters.
 * A semi-transparent, aqua particle that uses the first subimage of spr_pieces.
 * Last for 60 frames exactly and starts times times larger, reducing by 10% every frame.
 * Using the same values for a function that requires a minimum and maximum, uses just that single value.
 * Lastly, only one particle will be emitted when this is called. */
pt[0, 0] = part_type_create();
part_type_life(pt[0], 60, 60);
part_type_sprite(pt[0,0], spr_pieces, false, false, false);
part_type_color1(pt[0,0], c_aqua);
part_type_alpha1(pt[0,0], 0.75);
part_type_size(pt[0], 2, 2, -0.1, 0);
pt[0, 1] = 1;

/* Initializes second particle type.
 * Creates a red spark particle that last for about 10 to 15 frames.
 * Transitions from opaque red to a fully transparent, lighter red.
 * The particle will move in all directions at with varying speed.
 * 50 particles will be emitted each time this particle is requested.
 */
pt[1, 0] = part_type_create();
part_type_life(pt[1,0], 10, 15);
part_type_shape(pt[1, 0], pt_shape_spark);
part_type_color2(pt[1, 0], c_red, make_color_rgb(255,192,192));
part_type_alpha2(pt[1, 0], 1, 0);
part_type_size(pt[1, 0], 0.5, 1.5, 0, 0);
part_type_speed(pt[1,0], 2.5, 15, 0, 0);
part_type_direction(pt[1,0], 0, 360, 0, 0);
pt[1, 1] = 50;

/* Initializes third particle type. 
 * Creates star particles that transition from transparent and yellow to opaqur lime to transparent green.
 * They will burst upwards, but then be pulled down by gravity.
 * The orientation or rotation will also be random and not relative to its speed.
*/
pt[2, 0] = part_type_create();
part_type_life(pt[2,0], 10, 40);
part_type_shape(pt[2, 0], pt_shape_star);
part_type_color3(pt[2, 0], c_yellow, c_lime, c_green);
part_type_alpha3(pt[2, 0], 0, 1, 0);
part_type_speed(pt[2,0], 10, 20, 0, 0);
part_type_direction(pt[2,0], 45, 135, 0, 0);
part_type_orientation(pt[2,0], 0, 360, 0, 0, false);
part_type_gravity(pt[2,0], 2, 270);
pt[2, 1] = 10;

/* Initializes fourth particle type.
 * Line particles that burst outward from their center point, oritented by their direction.
 * The colors transition from black to yellow but is also additive.
 * The consistent speed will be slowed down every step, giving the illusion of friction. */
pt[3, 0] = part_type_create();
part_type_life(pt[3,0], 10, 15);
part_type_color_mix(pt[3,0], c_black, c_yellow);
part_type_alpha2(pt[3,0], 1, 0);
part_type_blend(pt[3,0], true);
part_type_shape(pt[3,0], pt_shape_line);
part_type_speed(pt[3,0], 15, 15, -1, 0);
part_type_direction(pt[3,0], 0, 360, 0, 0);
part_type_orientation(pt[3,0], 0, 0, 0, 0, true);
pt[3, 1] = 10;

/* Initializes fifth particle type.
 * Creates rings that are squashed on their y-axis due to the adjustment in scale.
 * They transition from fully opaque aqua to semi transparent white and ending in fully transparent blue.
 * They are initially launched downwards and pulled up by their gravity and spin. */
pt[4, 0] = part_type_create();
part_type_life(pt[4,0], 15, 45);
part_type_shape(pt[4,0], pt_shape_circle);
part_type_scale(pt[4,0], 1, 0.5);
part_type_color3(pt[4,0], c_aqua, c_white, c_blue);
part_type_alpha3(pt[4,0], 1, 0.75, 0);
part_type_speed(pt[4,0], 4, 15, -0.015, 1);
part_type_direction(pt[4,0], -135, -45,0,0);
part_type_orientation(pt[4,0],45, 135, 15, 0, false);
part_type_gravity(pt[4,0], 1, 90);
pt[4, 1] = 10;

/* Initializes sixth particle type. 
 * Creates disk-shaped particles that grow using wiggle.
 * They are shot out and also reduced over time.
 * Their colors are set using randomized hues, saturations, and values.
 * They also rotated around their origin. */
pt[5, 0] = part_type_create();
part_type_life(pt[5,0], 15, 30);
part_type_shape(pt[5, 0], pt_shape_disk);
part_type_color_hsv(pt[5, 0], 192, 255, 0, 255, 128, 255);
part_type_alpha2(pt[5, 0], 1, 0);
part_type_size(pt[5,0], 0.25, 0.35, 0, 1);
part_type_direction(pt[5,0], 0, 360, 12.5, 0);
part_type_speed(pt[5, 0], 2, 4, -0.05, 0);
pt[5, 1] = 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Destroys all particle types managed by this object.

// Destroys each particle type first.
var i;
for (i = 0; i &lt; part_count; i++)
{
    part_type_destroy(pt[i, 0]);
    pt[i, 0] = noone;
}

// Destroys the particle system.
part_system_destroy(ps);
ps = noone;

// Removes the reference of this Object from the global variable.
global.ps_manager = noone;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Particle System Code Sample

// Creates a new particle system, returning its id.
ps = part_system_create();

/* Sets the depth of the particle system.
 * argument0 is the id of the particle system.
 * argument1 is the depth, similar to object's depth. */
part_system_depth(ps, 0);

// Clears the system of all particles currently being rendered.
part_system_clear(ps);

// Returns true if a particle exists at the given id; otherwise, false is returned.
part_system_exists(ps);

/* Determine if the given particle system will draw new particles on top of old particles or the other way around.
 * argument0 is the particle system id.
 * argument1, if true, old particles are drawn on top of new ones; false for the opposite. */
part_system_draw_order(ps, true);

/* Specifies if the particle system should update by itself
 * argument1, if true, the particle system will update the particles automatically; otherwise it won't. */
part_system_automatic_update(ps, false);

//Simialr to part_system_automatic_update, except determines if the particles will be rendered automatically or not.
part_system_automatic_draw(ps, false);

// Updates the particle system.  Can be used to fast forward a particle system, or to update the particle system if it does not automatically update.
part_system_update(ps);

// Draws the particle system, mostly used to renderer a particle system that is not being drawn automatically.
part_system_drawit(ps);

/* Moves the particle system.
 * argument0 is the particle system id.
 * argument1 is the x-coordinate.
 * argument2 is the y-coordinate.
 * Moves all particles and emitters associated with the system. */
part_system_position(ps, 100, 100);

// Destroys the particle system.  Particle systems are persistent so it's good practice to destroy particle systems no longer needed.
part_system_destroy(ps);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Particle Emitter Code Sample

// Creates a particle emitter associated with the given system.
pe = part_emitter_create(ps);

// Clears the emitter to its default properties.
part_emitter_clear(ps, pe);

// Returns whether or not the given particle emitter exists.
part_emitter_exists(ps, pe);

/* Set the position, shape, and distribution of the particle emitter.
 * argument0 is the particle system.
 * argument1 is the particle emitter.
 * argument2 and argument3 are the x minimum and x maximum in which particles will be created.
 * argument4 and argument5 are the y minimum and y maximum in which particles will be created.
 * argument6 is the shape the emitter takes.
 * argument7 is the type of distribution the emitter uses. */
part_emitter_region(ps, pe, 0, 100, 0, 100, ps_shape_line, ps_distr_linear);

/* Burst a specificed number of particle from an emitter.  Occurs one and is best for one-off effects such as explosions.
 * argument0 is the particle system id.
 * argument1 is the particle emitter id.
 * argument2 is the particle type id.
 * argument3 is the number of particles to burst. */
part_emitter_burst(ps, pe, pt, 100);

/* Streams a specified particle type from an emitter.  Occurs every step and is best for persistent effects such as rain.
 * argument0 is the particle system id.
 * argument1 is the particle emitter id.
 * argument2 is the particle type id.
 * argument3 id the number of particles to be produced every step. */
part_emitter_stream(ps, pe, pt, 30);

// Destroys the emitter, removing it from memories.  Particles will stop being produced by the emitter but not cleared.
part_emitter_destroy(ps, pe);

// Destroys all emitters associated with the given particle system.
part_emitter_destroy_all(ps);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Particle Type Code Sample

// Creates a new particle type, returning its id.
pt = part_type_create();

// Resets all properties of the specified particle type to its default.  Does not change or clear particles currently being rendered of this type.
part_type_clear(pt);

/* Determines how long a particle type will last in frames.
 * argument0 is the particle type id.
 * argument1 is the minimum amount of life a particle will exist.
 * argument2 is the maximum amount of life a particle will exist. */
part_type_life(pt, 10, 50);

/* Defines a shape for the particle type to use. 
 * argument1 is the shape of the particle, using several pre-defined constants. */
part_type_shape(pt, pt_shape_circle);

/* Defines a sprite for the particle type to use.
 * argument1 is the sprite resource id.
 * argument2, if true, the particle will animate.
 * argument3, if true, the particle animation will stretch over the lifetime of the particle.
 * argument4, if true, a random subimage of the sprite will be chose to represent the particle.
*/
part_type_sprite(pt, spr_particle, false, false, false);

// Sets the blending color of the specified particle type.
part_type_color1(pt, c_red);

/* Sets the blending of two colors over the lifetime of a particle.  
 * The particle will start at as the color specified as argument1 and interpolate to the color used in argument2. */
part_type_color2(pt, c_red, c_white);

/* Sets the blending of three colors over the lifetime of a particle.  
 * The particle will start at as the color specified as argument1 and interpolate to the color used in argument2 around 50% of its life, and then finally to color 3 */
part_type_color3(pt, c_red, c_white, c_blue);

/* Defines two colors that the created particles will interpolate between */
part_type_color_mix(pt, c_black, c_white);

/* Defines ranges for the blending color to be for the specified particle using rgb channels.
 * argument1 and argument2 are the min and max range of the red channel.
 * argument3 and argument4 are the min and max range of the green channel.
 * argument5 and argument6 are the min and max range of the blue channel. */
part_type_color_rgb(pt, 0, 128, 0, 128, 0, 128);

/* Defines ranges for the blending color to be for the specified particle using hue, saturation, and value.
 * argument1 and argument2 are the min and max range of the hue.
 * argument2 and argument3 are the min and max range of the saturation.
 * argument4 and argument5 are the min and max range of the value. */
part_type_color_hsv(pt, 0, 128, 0, 128, 0, 128);

// Defines the alpha or transparency -- 0 to 1 -- of the specified particle type.
part_type_alpha1(pt, 0.55);

// Defines the alpha values that the specified particle type will interpolate between during its lifetime.
part_type_alpha2(pt, 1, 0);

// Defines three alpha values for the specified particle type to interpolate between during its lifetime.
part_type_alpha3(pt, 0, 1, 0);

// Defines if the specified particle type is rendered using additive blending (true) or alpha blending (false).
part_type_blend(pt, true);

// Defines the x and y scale of the specified particle.
part_type_scale(pt, x_scale, y_scale);

/* Defines the range of particle's size.
 * argument1 and argument2 define the minimum and maximum size range.
 * argument3 determines how much the size of the particle should increase (or decrease if negative) .
 * argument4 determines defines a random value to be added to the particle every step. */
part_type_size(pt, 0.1, 1, 0.001, 0);

/* Defines the direction that the particle moves.
 * argument1 and argument2 define the minimum and maximum angles of the direction in degrees.
 * argument3 will be added to the direction every step.
 * argument4 will specify a random value that will be added to the direction every frame. */
part_type_direction(pt, 0, 360, 0, 0);

/* Determines the visual rotation of the particle.
 * argument1 and argument2 define the minimum and maximum angles of the orientation in degrees.
 * argument3 will be added to the orientation of the particle every step.
 * argument4 will determine a random value that will be added to the orientation of the particle every step.
 * argument5 is a boolean that determines if the particle's orientation will be relative to the angle of its directional movement. */
part_type_orientation(pt, 0, 360, 0, 0, false);

/* Determines the speed at which the particle moves.  
 * argument1 and argument2 define the minimum and maximum speed of the particle.
 * argument3 is the amount of speed that will be added to the particle every step.
 * argument4 is the amount of randomized speed that will be added to the particle every step. */
part_type_speed(pt, 1, 2, 0, 0);

/* Determines the gravity of the specified particle.
 * argument1 is the strength of gravity.
 * argument2 is the angle of the gravity in degrees. */
part_type_gravity(pt, 1, 270);

/* Defines a particle to be created every step of the current particle's lifetime.
 * argument1 is the number of particles to create.
 * argument2 is the id of the other particle to create.
 * NEVER use the same particle type for argument0 and argument1 as this will cause an infinite loop and crash the game. */
part_type_step(pt, 1, other_pt);

/* Defines a particle to be created on the death of the current particle type.
 * argument1 is the number of particles to be created.
 * argument2 is the type of particle to be created. */
part_type_death(pt, 100, other_pt);

// Returns whether or not the specified particle type exists.
part_type_exists(pt)

// Removed the specified particle type from memory.
part_type_destroy(pt);

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Other Particle Function Code Sample

/* Creates a set of particles at the specified position.  Similar to having an emitter with no width or height.
 * argument0 is the particle system id.
 * argument1 is where the particles will be created on the x.
 * argiment2 is where the particles will be created on the y.
 * argument3 is the particle type id.
 * argument4 is the number of particles to create. */
part_particles_create(ps, 100, 100, pt, 50); 

// Identical to part_particles_create, except argument5 defines a blend color that overrides the particles current color.
part_particles_create_color(ps, 100, 100, pt, 50, c_red);

// Counts and returns the number of particles currently managed by the specified particle system.
part_particles_count(ps);

// Removes the visual representation of all particles currently managed by the specified particle system.
part_particles_clear(ps);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
